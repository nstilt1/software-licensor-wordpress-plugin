<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: register_store.proto

namespace Register_store_request;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Generated from protobuf message <code>register_store_request.Configs</code>
 */
class Configs extends \Google\Protobuf\Internal\Message
{
    /**
     * some notes about "frequency" and "expiration": 
     * the frequency dictates the minimum amount of time that must pass before a
     * client will reconnect with the server to check on the status of their 
     * license(s). This is important in case the user tries to remove a machine 
     * from their license, or if they were to refund their license purchase
     * the expiration dictates how long the client will be able to go without 
     * contacting the server. The expiration is important in the event that a
     * user were to deactivate a computer on their license, and if the 
     * "deactivated" client never reached back out to the server to find out 
     * that it is supposed to be deactivated
     *
     * Generated from protobuf field <code>uint32 offline_license_frequency_hours = 70;</code>
     */
    protected $offline_license_frequency_hours = 0;
    /**
     * Generated from protobuf field <code>uint32 perpetual_license_expiration_days = 80;</code>
     */
    protected $perpetual_license_expiration_days = 0;
    /**
     * Generated from protobuf field <code>uint32 perpetual_license_frequency_hours = 90;</code>
     */
    protected $perpetual_license_frequency_hours = 0;
    /**
     * Generated from protobuf field <code>uint32 subscription_license_expiration_days = 100;</code>
     */
    protected $subscription_license_expiration_days = 0;
    /**
     * these "leniency hours" get added onto the expiration date in case there's 
     * a niche timing unalignment with any communicating servers, such as the 
     * payment processor processing the subscription payment that has to be 
     * hooked from the store's backend that has to send a request to the 
     * licensing
     *
     * Generated from protobuf field <code>uint32 subscription_license_expiration_leniency_hours = 110;</code>
     */
    protected $subscription_license_expiration_leniency_hours = 0;
    /**
     * Generated from protobuf field <code>uint32 subscription_license_frequency_hours = 120;</code>
     */
    protected $subscription_license_frequency_hours = 0;
    /**
     * Generated from protobuf field <code>uint32 trial_license_expiration_days = 130;</code>
     */
    protected $trial_license_expiration_days = 0;
    /**
     * Generated from protobuf field <code>uint32 trial_license_frequency_hours = 140;</code>
     */
    protected $trial_license_frequency_hours = 0;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type int $offline_license_frequency_hours
     *           some notes about "frequency" and "expiration": 
     *           the frequency dictates the minimum amount of time that must pass before a
     *           client will reconnect with the server to check on the status of their 
     *           license(s). This is important in case the user tries to remove a machine 
     *           from their license, or if they were to refund their license purchase
     *           the expiration dictates how long the client will be able to go without 
     *           contacting the server. The expiration is important in the event that a
     *           user were to deactivate a computer on their license, and if the 
     *           "deactivated" client never reached back out to the server to find out 
     *           that it is supposed to be deactivated
     *     @type int $perpetual_license_expiration_days
     *     @type int $perpetual_license_frequency_hours
     *     @type int $subscription_license_expiration_days
     *     @type int $subscription_license_expiration_leniency_hours
     *           these "leniency hours" get added onto the expiration date in case there's 
     *           a niche timing unalignment with any communicating servers, such as the 
     *           payment processor processing the subscription payment that has to be 
     *           hooked from the store's backend that has to send a request to the 
     *           licensing
     *     @type int $subscription_license_frequency_hours
     *     @type int $trial_license_expiration_days
     *     @type int $trial_license_frequency_hours
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\RegisterStore::initOnce();
        parent::__construct($data);
    }

    /**
     * some notes about "frequency" and "expiration": 
     * the frequency dictates the minimum amount of time that must pass before a
     * client will reconnect with the server to check on the status of their 
     * license(s). This is important in case the user tries to remove a machine 
     * from their license, or if they were to refund their license purchase
     * the expiration dictates how long the client will be able to go without 
     * contacting the server. The expiration is important in the event that a
     * user were to deactivate a computer on their license, and if the 
     * "deactivated" client never reached back out to the server to find out 
     * that it is supposed to be deactivated
     *
     * Generated from protobuf field <code>uint32 offline_license_frequency_hours = 70;</code>
     * @return int
     */
    public function getOfflineLicenseFrequencyHours()
    {
        return $this->offline_license_frequency_hours;
    }

    /**
     * some notes about "frequency" and "expiration": 
     * the frequency dictates the minimum amount of time that must pass before a
     * client will reconnect with the server to check on the status of their 
     * license(s). This is important in case the user tries to remove a machine 
     * from their license, or if they were to refund their license purchase
     * the expiration dictates how long the client will be able to go without 
     * contacting the server. The expiration is important in the event that a
     * user were to deactivate a computer on their license, and if the 
     * "deactivated" client never reached back out to the server to find out 
     * that it is supposed to be deactivated
     *
     * Generated from protobuf field <code>uint32 offline_license_frequency_hours = 70;</code>
     * @param int $var
     * @return $this
     */
    public function setOfflineLicenseFrequencyHours($var)
    {
        GPBUtil::checkUint32($var);
        $this->offline_license_frequency_hours = $var;

        return $this;
    }

    /**
     * Generated from protobuf field <code>uint32 perpetual_license_expiration_days = 80;</code>
     * @return int
     */
    public function getPerpetualLicenseExpirationDays()
    {
        return $this->perpetual_license_expiration_days;
    }

    /**
     * Generated from protobuf field <code>uint32 perpetual_license_expiration_days = 80;</code>
     * @param int $var
     * @return $this
     */
    public function setPerpetualLicenseExpirationDays($var)
    {
        GPBUtil::checkUint32($var);
        $this->perpetual_license_expiration_days = $var;

        return $this;
    }

    /**
     * Generated from protobuf field <code>uint32 perpetual_license_frequency_hours = 90;</code>
     * @return int
     */
    public function getPerpetualLicenseFrequencyHours()
    {
        return $this->perpetual_license_frequency_hours;
    }

    /**
     * Generated from protobuf field <code>uint32 perpetual_license_frequency_hours = 90;</code>
     * @param int $var
     * @return $this
     */
    public function setPerpetualLicenseFrequencyHours($var)
    {
        GPBUtil::checkUint32($var);
        $this->perpetual_license_frequency_hours = $var;

        return $this;
    }

    /**
     * Generated from protobuf field <code>uint32 subscription_license_expiration_days = 100;</code>
     * @return int
     */
    public function getSubscriptionLicenseExpirationDays()
    {
        return $this->subscription_license_expiration_days;
    }

    /**
     * Generated from protobuf field <code>uint32 subscription_license_expiration_days = 100;</code>
     * @param int $var
     * @return $this
     */
    public function setSubscriptionLicenseExpirationDays($var)
    {
        GPBUtil::checkUint32($var);
        $this->subscription_license_expiration_days = $var;

        return $this;
    }

    /**
     * these "leniency hours" get added onto the expiration date in case there's 
     * a niche timing unalignment with any communicating servers, such as the 
     * payment processor processing the subscription payment that has to be 
     * hooked from the store's backend that has to send a request to the 
     * licensing
     *
     * Generated from protobuf field <code>uint32 subscription_license_expiration_leniency_hours = 110;</code>
     * @return int
     */
    public function getSubscriptionLicenseExpirationLeniencyHours()
    {
        return $this->subscription_license_expiration_leniency_hours;
    }

    /**
     * these "leniency hours" get added onto the expiration date in case there's 
     * a niche timing unalignment with any communicating servers, such as the 
     * payment processor processing the subscription payment that has to be 
     * hooked from the store's backend that has to send a request to the 
     * licensing
     *
     * Generated from protobuf field <code>uint32 subscription_license_expiration_leniency_hours = 110;</code>
     * @param int $var
     * @return $this
     */
    public function setSubscriptionLicenseExpirationLeniencyHours($var)
    {
        GPBUtil::checkUint32($var);
        $this->subscription_license_expiration_leniency_hours = $var;

        return $this;
    }

    /**
     * Generated from protobuf field <code>uint32 subscription_license_frequency_hours = 120;</code>
     * @return int
     */
    public function getSubscriptionLicenseFrequencyHours()
    {
        return $this->subscription_license_frequency_hours;
    }

    /**
     * Generated from protobuf field <code>uint32 subscription_license_frequency_hours = 120;</code>
     * @param int $var
     * @return $this
     */
    public function setSubscriptionLicenseFrequencyHours($var)
    {
        GPBUtil::checkUint32($var);
        $this->subscription_license_frequency_hours = $var;

        return $this;
    }

    /**
     * Generated from protobuf field <code>uint32 trial_license_expiration_days = 130;</code>
     * @return int
     */
    public function getTrialLicenseExpirationDays()
    {
        return $this->trial_license_expiration_days;
    }

    /**
     * Generated from protobuf field <code>uint32 trial_license_expiration_days = 130;</code>
     * @param int $var
     * @return $this
     */
    public function setTrialLicenseExpirationDays($var)
    {
        GPBUtil::checkUint32($var);
        $this->trial_license_expiration_days = $var;

        return $this;
    }

    /**
     * Generated from protobuf field <code>uint32 trial_license_frequency_hours = 140;</code>
     * @return int
     */
    public function getTrialLicenseFrequencyHours()
    {
        return $this->trial_license_frequency_hours;
    }

    /**
     * Generated from protobuf field <code>uint32 trial_license_frequency_hours = 140;</code>
     * @param int $var
     * @return $this
     */
    public function setTrialLicenseFrequencyHours($var)
    {
        GPBUtil::checkUint32($var);
        $this->trial_license_frequency_hours = $var;

        return $this;
    }

}

